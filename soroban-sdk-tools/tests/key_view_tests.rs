//! Tests for key viewing API methods generated by contractstorage macro.
//! Tests get_<struct>_<field>_key methods for retrieving storage keys.

use soroban_sdk::{contract, contractimpl, testutils::Address as _, Bytes, BytesN};
use soroban_sdk::{xdr::ToXdr, Address, Env, IntoVal, Symbol, TryFromVal, Val, Vec as HostVec};
use soroban_sdk_tools::{PersistentItem, PersistentMap};
use soroban_sdk_tools_macro::contractstorage;

// ============================================================================
// Auto-Shorten Contract with Key View Methods
// ============================================================================

mod autoshorten {
    use super::*;

    #[contractstorage(auto_shorten = true)]
    pub struct Storage {
        pub balance: PersistentMap<Address, u64>,
        pub total: PersistentItem<u64>,
        pub counters: PersistentMap<u32, u64>,
    }

    #[contract]
    pub struct KeyView;

    #[contractimpl]
    impl KeyView {}
}

// ============================================================================
// Non-Auto-Shorten (DataKey Style) with Key View Methods
// ============================================================================

mod datakey_style {
    use super::*;

    #[contractstorage]
    pub struct Storage {
        #[short_key = "bal"]
        balances: PersistentMap<Address, u64>,
        owner: PersistentItem<Address>,
        cells: PersistentMap<(u32, u32), u64>,
    }

    #[contract]
    pub struct DataKeyView;

    #[contractimpl]
    impl DataKeyView {}
}

// ============================================================================
// Mixed Explicit and Auto Keys
// ============================================================================

mod mixed {
    use super::*;

    #[contractstorage(auto_shorten = true)]
    pub struct Storage {
        #[short_key = "x"]
        mapx: PersistentMap<Address, u64>,
        itemy: PersistentItem<u64>,
        #[short_key = "c"]
        cells: PersistentMap<(u32, u32), u64>,
    }

    #[contract]
    pub struct Mixed;

    #[contractimpl]
    impl Mixed {}
}

// ============================================================================
// Tests for Auto-Shorten Keys
// ============================================================================

#[test]
fn test_autoshorten_map_key_view() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());
    let storage = autoshorten::Storage::new(&env);

    let addr = Address::generate(&env);

    // Get the key for balance map with specific address
    let key_val = storage.get_storage_balance_key(addr.clone());

    // Verify it's a hashed key
    env.as_contract(&id, || {
        use soroban_sdk_tools::key::make_map_key;

        let prefix_b = Bytes::from_slice(&env, b"B");
        let expected_key: Val = make_map_key(&env, &prefix_b, &addr);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

#[test]
fn test_autoshorten_item_key_view() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());
    let storage = autoshorten::Storage::new(&env);

    // Get the key for total item
    let key_val = storage.get_storage_total_key();

    // Verify it's short Bytes "T"
    env.as_contract(&id, || {
        let expected_key: Val = Bytes::from_slice(&env, b"T").into_val(&env);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

#[test]
fn test_autoshorten_numeric_map_key_view() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());
    let storage = autoshorten::Storage::new(&env);

    // Get the key for counters map with numeric key
    let key_val = storage.get_storage_counters_key(42u32);

    // Verify it's a hashed key
    env.as_contract(&id, || {
        use soroban_sdk_tools::key::make_map_key;

        let prefix_c = Bytes::from_slice(&env, b"C");
        let expected_key: Val = make_map_key(&env, &prefix_c, &42u32);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

// ============================================================================
// Tests for DataKey Style Keys
// ============================================================================

#[test]
fn test_datakey_map_key_view() {
    let env = Env::default();
    let id = env.register(datakey_style::DataKeyView, ());
    let addr = Address::generate(&env);
    let storage = datakey_style::Storage::new(&env);

    // Get the key for balances map (uses short_key "bal")
    let key_val = storage.get_storage_balances_key(addr.clone());

    // Verify it's Vec[Symbol("Bal"), Address]
    env.as_contract(&id, || {
        let mut expected: HostVec<Val> = HostVec::new(&env);
        expected.push_back(Symbol::new(&env, "Bal").into_val(&env));
        expected.push_back(addr.into_val(&env));
        let expected_key: Val = expected.into_val(&env);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

#[test]
fn test_datakey_item_key_view() {
    let env = Env::default();
    let id = env.register(datakey_style::DataKeyView, ());
    let storage = datakey_style::Storage::new(&env);

    // Get the key for owner item (no short_key, uses "Owner")
    let key_val = storage.get_storage_owner_key();

    // Verify it's Symbol("Owner")
    env.as_contract(&id, || {
        let expected_key: Val = Symbol::new(&env, "Owner").into_val(&env);
        assert!(key_val.shallow_eq(&expected_key));
    });
}

#[test]
fn test_datakey_tuple_map_key_view() {
    let env = Env::default();
    let id = env.register(datakey_style::DataKeyView, ());
    let storage = datakey_style::Storage::new(&env);

    // Get the key for cells map with tuple key
    let key_val = storage.get_storage_cells_key((3u32, 4u32));

    // Verify it's Vec[Symbol("Cells"), tuple]
    env.as_contract(&id, || {
        let mut tuple: HostVec<Val> = HostVec::new(&env);
        tuple.push_back((3u32).into_val(&env));
        tuple.push_back((4u32).into_val(&env));

        let mut expected: HostVec<Val> = HostVec::new(&env);
        expected.push_back(Symbol::new(&env, "Cells").into_val(&env));
        expected.push_back(tuple.into_val(&env));
        let expected_key: Val = expected.into_val(&env);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

// ============================================================================
// Tests for Mixed Keys
// ============================================================================

#[test]
fn test_mixed_explicit_map_key_view() {
    let env = Env::default();
    let id = env.register(mixed::Mixed, ());
    let addr = Address::generate(&env);
    let storage = mixed::Storage::new(&env);

    // Get the key for mapx (explicit short_key "x")
    let key_val = storage.get_storage_mapx_key(addr.clone());

    // Verify it's hashed with prefix "x"
    env.as_contract(&id, || {
        use soroban_sdk_tools::key::make_map_key;

        let prefix_x = Bytes::from_slice(&env, b"x");
        let expected_key: Val = make_map_key(&env, &prefix_x, &addr);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

#[test]
fn test_mixed_auto_item_key_view() {
    let env = Env::default();
    let id = env.register(mixed::Mixed, ());
    let storage = mixed::Storage::new(&env);

    // Get the key for itemy (auto-shortened to "I")
    let key_val = storage.get_storage_itemy_key();

    // Verify it's short Bytes "I"
    env.as_contract(&id, || {
        let expected_key: Val = Bytes::from_slice(&env, b"I").into_val(&env);
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

#[test]
fn test_mixed_explicit_tuple_map_key_view() {
    let env = Env::default();
    let id = env.register(mixed::Mixed, ());
    let storage = mixed::Storage::new(&env);

    // Get the key for cells (explicit short_key "c")
    let key_val = storage.get_storage_cells_key((10u32, 20u32));

    // Verify it's hashed with prefix "c"
    env.as_contract(&id, || {
        use soroban_sdk_tools::key::make_map_key;

        let prefix_c = Bytes::from_slice(&env, b"c");
        let expected_key: Val = make_map_key(&env, &prefix_c, &(10u32, 20u32));
        assert_eq!(key_val.to_xdr(&env), expected_key.to_xdr(&env));
    });
}

// ============================================================================
// Tests for Key Consistency
// ============================================================================

#[test]
fn test_key_consistency_with_actual_storage() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());

    let addr = Address::generate(&env);

    env.as_contract(&id, || {
        let storage = autoshorten::Storage::new(&env);

        storage.balance.set(&addr, &999);

        // Get the key using the view method
        let key_val = storage.get_storage_balance_key(addr.clone());

        // Verify the key exists in storage with the expected value
        let stored_value: u64 = env.storage().persistent().get(&key_val).unwrap();
        assert_eq!(stored_value, 999);
    });
}

#[test]
fn test_key_view_different_keys_for_different_values() {
    let env = Env::default();
    let addr1 = Address::generate(&env);
    let addr2 = Address::generate(&env);
    let storage = autoshorten::Storage::new(&env);

    // Get keys for different addresses
    let key1 = storage.get_storage_balance_key(addr1);
    let key2 = storage.get_storage_balance_key(addr2);

    // Verify they are different
    assert_ne!(key1.to_xdr(&env), key2.to_xdr(&env));
}

#[test]
fn test_key_view_same_key_for_same_value() {
    let env = Env::default();
    let addr = Address::generate(&env);
    let storage = autoshorten::Storage::new(&env);

    // Get key twice for same address
    let key1 = storage.get_storage_balance_key(addr.clone());
    let key2 = storage.get_storage_balance_key(addr);

    // Verify they are the same
    assert_eq!(key1.to_xdr(&env), key2.to_xdr(&env));
}

#[test]
fn test_hashed_key_is_32_bytes() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());
    let addr = Address::generate(&env);
    let storage = autoshorten::Storage::new(&env);

    // Get the key for balance map (should be hashed because composite > 32 bytes)
    let key_val = storage.get_storage_balance_key(addr);

    // Verify it's a BytesN<32>
    env.as_contract(&id, || {
        let key = BytesN::<32>::try_from_val(&env, &key_val);
        assert!(key.is_ok());
        assert_eq!(key.unwrap().len(), 32);
    });
}

#[test]
fn test_short_key_not_hashed() {
    let env = Env::default();
    let id = env.register(autoshorten::KeyView, ());
    let storage = autoshorten::Storage::new(&env);

    // Get the key for total item (should be short Bytes, not hashed)
    let key_val = storage.get_storage_total_key();

    // Verify it's regular Bytes, not BytesN<32>
    env.as_contract(&id, || {
        let bytes = Bytes::try_from_val(&env, &key_val);
        assert!(bytes.is_ok());
        assert_eq!(bytes.unwrap().len(), 1); // Just "T"
    });
}
